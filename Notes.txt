run updatedb to make sure everything is up to date. Used for making sure created files are recognized in terminal.

locate test.txt ==> This will show the directory or better to say the address of test.txt in our machine

ls -la ==> This will show all the files and directories in list format.

List format will show us:
At the left most part we'll have couple of letters moving from left to right showing:
first left most letter is d or - which d is for directory and - is for file
The next 3 letters will be rwx or - for each this is for readable writeable executable if there's a - this means that for the item that specific process is not possible. These first 3 letters is for the owner of the file meaning root.
There are 2 3 letters part left everything is the same but for these the first 3 letters will be for group which root has created and the next 3 will be for all permissions meaning everyone else.

su Ali ==> Switches to Ali
su - ==> Switches to root

Important files:
/etc/passwd ==> For seeing the users on the machine (create new user by adduser Ali)
/etc/shadow ==> Passwords in hash format ==> Only root can access it or better to say sudoers ==> sudoers are kept for knowing which users can access certain files

ping -c 1 192.168.1.1 > ip.txt
cat ip.txt | grep "64 bytes" | cut -d " " -f 4 | tr -d ":"
First we ping the ip address and get some results that show either it's up or not. | will create new pipes meaning that after cat ip.txt we'll run grep "64 bytes" command. grep "64 bytes" will give out the line that has "64 bytes" in it. We have to find something unique about the results when the machine is up r down something like 64 bytes or 1 received 64 bytes is much better since it'll have the ip address on the same line. cut -d " " -f 4 is like sentence.split(" ")[4] starting from index zero. The 4th field is ip address of the machine that is up. The ip will have : at the end of it by running tr -d ":" we can get rid of it so at last we'll get the ip address that is up.

ipsweep.sh => find ips that are up in your network
##################################################
#!/bin/bash

for ip in `seq 1 254`; do
ping -c 1 $1.$ip | grep "64 bytes" | cut -d " " -f 4 | tr -d ":" &
done
##################################################
Notes from the script above:
$1 is user input meaning that when we run ./ipsweep.sh 192.168.1 in terminal $1 will be 192.168.1
$ip will be numbers from 1 to 254.
We can end the ping command with ; instead of & but & will use thread to run ipsweep all at once meaning that it'll us parallelism but ; will do each ping command then it'll go to the next one but with & all of them can be done in parallel.
After saving the script for running it we have to make it executable now it's just readable and writable for root. To make it executable we'll use chmod +x ipsweep.sh or chmod 777 ipsweep.sh now it'll be executable for everyone not just root.
After running it using ./ipsweep 192.168.1 > ipList.txt for example we'll have all the up ip addresses in the network saved in ipList.txt.

We can add #!/bin/python3 and chmod to 777 to execute python script without calling python3 every time. python3 ./script.py => ./script.py

python3 -m http.server 8000 ==> This will create a http server with 0.0.0.0:8000 as address and by putting the address above into the browser you can access current directory.

python3 -m pyftpdlib -p 8000 -w ==> This will create a ftp server with 0.0.0.0:8000 as address and by putting the address ftp://0.0.0.0:8000 into the browser you can access current directory. The -w is used to give write permission to anonymous user it's not necessary to put it in command. I couldn't load up directory as http server and I didn't find out why!!!

s = socket.socket(socket.AF_INET , socket.SOCK_STREAM) ==> creates socker
s.connect_ex((ip , port)) ==> if this returns 0 this means it has connected successfully
socket.gaierror occures when the connection isn't established by socket to the hostname
socket.error occures when there's no connection at all like server is down

crt.sh is a good site for finding and checking subdomains

Wappalyzer is great tool that helps us find out info about the site that we're visiting. It's an extension that can be added to browser. The info can be the framework the site is using, the libraries that the site is using, the web server and many more.

builtwith.com gives a lot of useful info about the target site just by entering the site url.

***** Wireshark & nmap *****
We know 3-way handshake already SYN-SYN ACK-ACK but for stealth search it's like SYN-SYN ACK-RST where RST is like jk I was just checking if I can connect to you or not. But this method isn't that stealthy anymore.

nmap has a lot of tools for scanning.

nmap -sn 192.168.1.0/24 ==> is like a ping sweep

nmap -T4 192.168.1.1 ==> This will search for top 1000 open ports on the IP address. -T4 means the quality of the search like if it's -T1 then it'll be slow but much more accurate but -T5 on the other hand is fast but it's the least accurate option. Only the top 1000 ports sometimes isn't enough maybe there's an open port on 8000 so what now.

nmap -T4 -A -p- 192.168.1.1 ==> This is like the last one but -A will give as much info as possible. For seeing what are the info of -A (which means all) you can run nmap --help | grep -e "-A:". Also in -p- the part with -p is for adding the port number that we want to check but putting - after -p means search all ports. The bad thing here is that this command would take for ages to give the results so we have to imporve and hit a sweet spot between last command and this command.

So one way to make the operation more efficient is to first search for open ports by nmap -T4 -p- 192.168.1.1 then when we got all the open ports we can do a more depthed search on the open ports by running something like nmap -T4 -A -p43,80,221 192.168.1.1 this would only search the found open ports using -A meaning it'll take much less time than running -A on all ports. This way of doing is called staging. 

You can use uparrow key in terminal to see how much of nmap's work is left like get the remaining time and that stuff.

nmap -T4 -p- 192.168.1.1 -oN openPorts ==> This will put all the open ports in normal form in a file named openPorts
grep "/tcp" openPorts | cut -d " " -f 1 | cut -d "/" -f 1 ==> This will give us the port numbers

##################################################
#!/bin/bash

cat openPorts | grep "/tcp" | cut -d " " -f 1 | cut -d "/" -f 1 | while read port
do
	nmap -T4 -A -p$port 192.168.1.1
done
##################################################
The script above will use created file from before (openPorts) to iterate through open ports and run -A scans on them. Courtesy of yours truly. (Maybe putting an & at the end of nmap command will result in threading like before and make it even faster but I haven't tried it)

nmap -sU -T4 192.168.1.1 ==> This one is for UDP and everything else is the same. 95% of the time TCP is in place so we're gonna do like before but this also comes in handy for UDP for that 5%.

Burp suite importent tool for web app pen testing.

Nessus is also a very informative tool for gathering info.

Another one is nikto which will give a lot of info as well.
nikto -h 192.168.1.6 for example.

netdiscover -r 192.168.1.0/24 ==> This will show all the IP addresses starting with 192.168.1

curl --head 192.168.1.6 ==> This will return the header of response when requesting the input url

nmap --script=ssl-enum-ciphers -p 443 192.168.1.6 ==> This will return all the ciphers that the url on that port is using
SSL cipher suites determine the method through which a secure connection will take place between both entities.
443 is for https.

searchsploit apache 1.3 ==> This will show the vulnerabilities of apache 1.3 for example but we can search for other things as well
To install searchsploit on ubuntu there are tutorials online by cloning a github repo.


############### NEW COURSE MATERIAL ###############
